# MySQL实战

# MySQL实战 # 如何定义字段类型？

MySQL 中有很多字段类型，比如整数、文本、浮点数，等等。如果类型定义合理，就能节省存储空间，提升数据查询和处理的速度；相反，如果数据类型定义不合理，就有可能会导致真实数据超出数据类型取值范围，引发系统报错，甚至可能会出现计算错误的情况，进而影响到整个系统。

比如，最常见的就是**浮点数的精度问题**。这个问题最典型案例的就是“价格精度问题”。价格一般以元为单位，因此角和分就需要使用浮点数来表示。而 DOUBLE 这种类型其实是无法保证数据的精度的，可能造成用户多付款或少付款的情况，这是不能被接受的错误。



## 整数类型

整数类型一共有 5 种，包括 **TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT**，它们的区别如下表所示：

| 类型      | 有符号数取值范围                          | 无符号数取值范围        | 占用字节数 | 适用场景                                                     |
| --------- | ----------------------------------------- | ----------------------- | ---------- | ------------------------------------------------------------ |
| TINYINT   | -128~127                                  | 0~255                   | 1          | —般用于枚举数据                                              |
| SMALLINT  | -32768～32767                             | 0～65535                | 2          | 可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等 |
| MEDIUMINT | -8388608～8388607                         | 0~16777215              | 3          | 用于较大的整数计算，比如车站每日的客流量等                   |
| INT       | -2147483648～2147483647                   | 0~4294967295            | 4          | 取值范围足够大，一般情况下不用考虑超限问题，用得最多         |
| BIGINT    | -9223372036854775808～9223372036854775807 | 0～18446744073709551615 | 8          | 只有当你处理特别大的整数时才会用到，比如双十一的交易量、大型门户网点的点击量等 |

### 如何选择合适的整数类型？

选择原则：**存储空间和可靠性的平衡**。

一方面，使用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起系统错误，影响可靠性。



举个例子，在线下超市的数据库系统中，商品编号采用的数据类型一般是 INT。之所以没有采用占用字节更少的 SMALLINT 类型整数，是因为客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少,但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。

而如果是一个大型的电商平台，比如淘宝、京东等，它们的商品种类要远大于线下的超市平台，所以它们可能不会选择 INT 类型，而是选择取值范围更高的 BIGINT 类型。

> **Dangers**
>
> 在实际工作中，系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因此，我们首先需要确保业务数据不会超过数据类型的取值范围，在这个前提之下，再去考虑如何节省存储空间。



## 浮点数 vs. 定点数

### 浮点数

浮点数和定点数类型的特点是可以处理小数，**你可以把整数看成小数的一个特例**。因此，浮点数和定点数的使用场景，就比整数大多了.

MySQL 支持的浮点数类型有：**FLOAT、DOUBLE、REAL**

- FLOAT 表示单精度浮点数；

- DOUBLE 表示双精度浮点数；

- REAL 默认就是 DOUBLE。如果你把 SQL 模式设定为启用 `REAL_AS_FLOAT`，那么，MySQL 就认为 REAL 是 FLOAT。如果要启用 `REAL_AS_FLOAT`，可以通过以下 SQL 语句实现：

  ```mysql
  SET sql_mode = "REAL_AS_FLOAT";
  ```



#### FLOAT vs. DOUBLE

FLOAT 和 DOUBLE 的区别就是：

- FLOAT 占用的字节数少，取值范围小；
- DOUBLE 占用的字节数多，取值范围大。

| 类型   | 有符号数取值范围                                             | 无符号数取值范围                                     | 字节数 |
| ------ | ------------------------------------------------------------ | ---------------------------------------------------- | ------ |
| FLOAT  | (-3.402823466E+38，-1.175494351E-38)，0，(1.175494351 E-38，3.402823466351 E+38) | 0，(1.175494351 E-38,3.402823466 E+38)               | 4      |
| DOUBLE | (-1.7976931348623157E+308，-2.2250738585072014E-308)，0，(2.2250738585072014E-308,1.7976931348623157E+308) | 0，(2.2250738585072014E-308,1.7976931348623157E+308) | 8      |



#### 浮点数的缺陷

浮点数最大的缺陷就是：**不精准**。因此，在一些对精度要求较高的项目中，千万不要使用浮点数，不然就会导致结果错误，造成不可挽回的损失。



### 定点数（DECIMAL）

为了解决浮点数存储数据精度不够的问题，MySQL 还提供了一种精准的数据类型——定点数（DECIMAL）。



就像浮点数的存储方式决定了它不可能精准一样，DECIMAL 的存储方式决定了它一定是精准的。

浮点数类型是把十进制数转换成二进制数存储，DECIMAL 则不同，它是**把十进制数的整数部分和小数部分拆开，分别转换成十六进制数，进行存储**。这样，所有的数值就不会存在因为无法表达而损失精度的问题了。

MySQL 用 `DECIMAL (M,D)` 的方式表示高精度小数。其中，M 表示整数部分加小数部分，一共有多少位（`M<=65`）；D 表示小数部分位数（`D<M`）。



### 浮点数和定点数的使用场景

由于 DECIMAL 数据类型的精确性，在常见的支付场景、商品重量场景下使用 DECIMAL 比较好。但是，浮点数也并非没有优势，在某些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表示的范围会更大一些。



**小结：**

- 浮点数取值范围大，但不精确。
- 定点数类型取值范围较小，但是精确，没有误差。



## 文本类型

实际项目中，另一种常见的数据就是文本类型数据。MySQL 支持 **CHAR、VARCHAR、TEXT、ENUM、SET** 等文本类型。它们的区别如下：

- `CHAR(M)`：固定长度字符串。`CHAR(M)` 类型必须预先定义字符串长度。如果太短，数据可能会超出范围；如果太长，又浪费存储空间。
- `VARCHAR(M)`：可变长度字符串。`VARCHAR(M)` 需要预先定义字符串的**最大长度**，只要不超过这个最大长度，具体存储的时候，是按照实际字符串长度存储的。
- `TEXT`：字符串。系统自动按照实际长度存储，不需要预先定义长度。
- `ENUM`：枚举类型，取值必须是预先设定的一组字符串值范围之内的一个，必须要知道字符串所有可能的取值。
- `SET`：是一个字符串对象，取值必须是在预先设定的字符串值范围之内的 0 个或多个，也必须知道字符串所有可能的取值。
  - 对于 ENUM 类型和 SET 类型来说，你必须知道所有可能的取值，所以只能用在某些特定场合，比如某个参数设定的取值范围只有几个固定值的场景。

> Tip：**我司建议尽量不使用 Enum 类型代替 Tinyint**





### TEXT

因为不需要预先知道字符串的长度，系统会按照实际的数据长度进行存储，所以 TEXT 类型非常灵活方便。

TEXT 类型也有 4 种，它们的区别就是最大长度不同。

- `TINYTEXT`：255字符（这里假设字符是ASCIl码，一个字符占用一个字节，下同）
- `TEXT`：65535字符。
- `MEDIUMTEXT`：16777215字符。
- `LONGTEXT`：4294967295字符（相当于4GB)。



#### TEXT存在的问题

TEXT 首先存在的问题就是效率不如 CHAR(M) 和 VARCHAR(M)。其次，还存在以下两个访问的问题：

**Case1：**

- **由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况，你只能采用 CHAR(M) 或者 VARCHAR(M)**。



**Case2：**

- 因为 InnoDB 存储数据的最小单位是 page，单个 page 的数据容量是 16K，而 TEXT 类型最大能达到 64k，这就会导致 TEXT 文本可能需要存储在多个 Page 中，影响查询效率。

> **Tip：**
>
> 在实际开发中，我司不建议使用 Text 类型。







## 日期与时间类型

开发中最常用的第四类数据类型就是：日期与时间类型。

**MySQL 中用得最多的日期时间类型，就是 DATETIME 和 TIMESTAMP**。虽然 MySQL 也支持 **YEAR**(年)、**TIME**(时间)、**DATE**(日期) 等类型，但在实际项目中，尽量使用DATETIME 或 TIMESTAMP 比较好，因为这个数据类型包括了完整的日期和时间信息，使用起来比较方便。如果日期时间信息分散在好几个字段，就会很不容易记，而且查询的时候，SQL 语句也会更加复杂。

下面是 MySQL 支持的其他日期时间类型的一些参数：

| 类型      | 日期格式            | 范围                                             | 占用字节数 |
| --------- | ------------------- | ------------------------------------------------ | ---------- |
| YEAR      | YYYY                | 1901～2155                                       | 1          |
| TIME      | HH:MM:SS            | -838:59:59～838:59:59                            | 3          |
| DATE      | YYYY-MM-DD          | 1000-01-01~9999-12-3                             | 3          |
| DATETIME  | YYYY-MM-DD HH:MM:SS | 1000-01-0100:00:00~9999-12-3123:59:59            | 8          |
| TIMESTAMP | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:01 UTC～2038-01-19 03:14:07 UTC | 4          |



### DATETIME vs. TIMESTAMP

DATETIME 和 TIMESTAMP 的优缺点是显而易见的，

- DATETIME 可以存储从 1000~9999年内的时间范围，而 TIMESTAMP 只能存储从1970~2037 年的时间范围；
- 但是 DATETIME 相比 TIMESTAMP 会占用更大的存储空间。

不仅仅是这两个数据类型，不同的数据类型表示的时间内容不同，取值范围不同，而且占用的字节数也不一样，在真正使用中还需要**因地制宜**。

> **Tip：**我司建议使用 TIMESTAMP。



#### TIMESTAMP 使用注意事项（重要）：

- 在插入数据时，第一列的 TIMESTAMP 对自动更新为当前时间，而第二列则不会更新。









---------









 













# MySQL实战 # Primary Key：设置主键的三种思路

- 业务字段做主键
- 自增字段做主键
- 手动赋值字段做主键

### 业务字段做主键

需要确保业务字段不会被重用。

如果业务字段发生了重用（回收再使用），那么如果存在消费流水记录的话，可能会把该字段绑定的旧用户的消费记录继承给新用户，这在代码逻辑中是不会出错的，但在业务上却是不合适的。

**建议：**尽量不要使用业务字段做主键。





### 自增字段做主键

1. 修改原表，删除表的主键约束（这个操作并不会删除主键字段）

   ```mysql
   ALTER TABLE qunar0727.`author`
   DROP PRIMARY KEY;
   ```

   

2. 修改表，添加字段 id 作为主键，并为其添加自增约束

   ```mysql
   #添加id字段为主键，并定义自增约束
   ALTER TABLE qunar0727.`author`
   ADD id INT PRIMARY KEY AUTO_INCREMENT;
   ```

   



### 手动赋值字段做主键

如果存在多个线程同时进行写操作，存在 “id” 冲突的可能。

取消 id 的自增属性，改成信息系统在添加会员的时候对 “id” 进行赋值







-------

# 索引

## 单字段索引



创建单字段索引，一般有 3 种方式：

1. **给已经存在的表创建索引**
2. **在创建表的同时创建索引**
3. **通过修改表来创建索引**

直接给数据表创建索引的语法如下:

```mysql
CREATE INDEX ${索引名} ON ${表名(字段)};

# 给已经存在的表创建索引
CREATE INDEX index_author_id ON qunar0727.book(author_id);
```

创建表的同时创建索引

```mysql
# 创建表时创建索引
CREATE TABLE qunar0727.testIndex
(
	num INT,
	age INT,
	# 注意：创建索引要写在括号内而不是括号外
	INDEX  index_id (num)
);
```

修改表时创建索引

```mysql
# 修改表时创建索引
ALTER TABLE qunar0727.testIndex 
ADD INDEX(age);
```



## 如何选择索引字段？

- **在选择索引字段的时候，要选择那些经常被用作筛选条件的字段**。这样才能发挥索引的作用，提升检索的效率。



## 组合索引

**如果有多个索引，而这些索引的字段同时作为筛选字段出现在查询中的时候，MySQL 会使用最优的索引来执行查询操作。**但本质上这次查询只是用了单字段的索引。

MySQL 最多支持由 16 个字段组成的组合索引。

### 如何创建组合索引？



1. **给已经存在的表创建索引**
2. **在创建表的同时创建索引**
3. **通过修改表来创建索引**

```mysql
# 给已经存在的表创建索引
CREATE INDEX ${索引名} ON ${表名(字段1, 字段2, ...)};

# 给已经存在的表创建组合索引
CREATE INDEX idx_num_age ON qunar0727.`testIndex`(num, age);
```



创建表的时候同时创建索引

```mysql
# 创建表时创建索引
CREATE TABLE qunar0727.testIndex
(
	num INT,
	age INT,
	# 注意：创建索引要写在括号内而不是括号外
	INDEX  idx_num_age (num, age)
);
```

修改表时创建索引

```mysql
# 修改表时创建索引
ALTER TABLE qunar0727.testIndex 
ADD INDEX idx_num_age(num, age);
```





### 组合索引的原理

**组合索引的多个字段是有序的，遵循左对齐的原则。**

比如我们创建的组合索引，排序的方式是 id、name 和 age。因此，筛选条件也要遵循从左向右的原则。如果中断，那么，断点后面的条件就无法利用索引了。

比如，有一个查询条件 `id=101 and name="Jackson" and age=31`，包含了从左到右的所有字段，所以可以最大限度使用全部组合索引。

假如把条件换成 `name="Jackson" and age=31`，由于我们的组合索引是按照 id、name 和 age 的顺序建立的，最左边的字段 id 没有包含到条件当中，第一个字段就发生了中断，所以这个条件完全不能使用组合索引。



类似的，如果筛选条件是一个范围，由于无法精确定位，也相当于中断。比如  `id<101 and name="Jackson" and age=31` 这个条件，只能用到组合索引中 `id<101` 的部分，后面的索引就都失效了。

TODO：Explain



可以看到，MySQL 没有选择组合索引，而是选择了只有 id 的单列索引 unique_id。因为**如果只用组合索引的一部分，效果没有单列索引好**。



## 删除索引

删除普通索引

```mysql
# 删除普通索引
DROP INDEX idx_num_age ON qunar0727.`testIndex`;
```

当然，有的索引不能用这种方法删除，比如主键索引，你必须通过修改表来删除索引。语法如下：

```mysql
# 删除主键索引
ALTER TABLE qunar0727.`testIndex` DROP PRIMARY KEY;
```



## 索引的成本

索引能够有效提升查询的效率，但是建立索引也是有成本的，主要有 2 个方面：一个是存储空间的开销；另一个是数据操作上的开销。

- 存储空间的开销：是指索引需要单独占用存储空间。
- 数据操作上的开销：是指一旦数据表有变动，无论是插入一条新数据，还是删除一条旧数据，如果涉及索引字段，都需要对索引本身进行修改，以确保索引能够指向正确的记录。

因此，索引也不是越多越好，创建索引有存储开销和操作开销，需要综合考虑。

